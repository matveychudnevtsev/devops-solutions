def modifyHeaders(selectedManifest, userInputPolicies, manifestsMap, envoyFilters) {
    selectedManifest.each { manifestName ->
        // Шаг 1: Пользователь выбирает префиксы
        def selectedPrefixes = userInputPolicies[manifestName].findAll { k, v -> v == true }.keySet()
        def updatedFilter = envoyFilters.items.find { it.metadata.name == manifestName }

        selectedPrefixes.each { prefix ->
            log.infoCustom "Обработка изменения headers для префикса ${prefix} в ${manifestName}"

            // Преобразуем префикс в безопасный для ключей формат
            def safePrefix = prefix.replaceAll(/[\/]/, "_")

            // Шаг 2: Поиск существующих регулярных выражений в выбранных префиксах
            def existingRegexes = []
            updatedFilter.spec.configPatches.each { patch ->
                def rules = patch.patch?.value?.typed_config?.rules
                if (rules?.policies) {
                    rules.policies.each { policyName, policyValue ->
                        // Проверка на наличие соответствующего prefix
                        def permissions = policyValue.permissions
                        def prefixExists = permissions?.any { permission ->
                            permission.and_rules?.rules?.any { rule ->
                                rule.url_path?.path?.prefix == prefix
                            }
                        }

                        if (prefixExists) {
                            policyValue.principals.each { principal ->
                                if (principal.header?.safe_regex_match?.regex) {
                                    existingRegexes.add(principal.header.safe_regex_match.regex)
                                }
                            }
                        }
                    }
                }
            }

            // Шаг 3: Пользователь выбирает, какое регулярное выражение изменить
            def regexChoices = []
            existingRegexes.each { regex ->
                regexChoices.add(booleanParam(name: "regex_${regex}", defaultValue: false, description: "Изменить: ${regex}"))
            }

            def selectedRegexToModify = input(
                id: "userInputRegexSelect_${manifestName}_${safePrefix}",
                message: "Выберите регулярное выражение для изменения в ${manifestName} - ${prefix}",
                parameters: regexChoices
            )

            // Логируем выбранное регулярное выражение
            def regexToModify = selectedRegexToModify.find { it.value == true }?.key?.replace('regex_', '')
            log.infoCustom "Пользователь выбрал для изменения регулярное выражение: ${regexToModify} для префикса ${prefix}"

            // Шаг 4: Пользователь вводит новое регулярное выражение
            def newRegexInput = input(
                id: "userInputRegexModify_${manifestName}_${safePrefix}",
                message: "Введите новое регулярное выражение для замены в ${manifestName} - ${prefix}",
                parameters: [string(name: "newRegex", defaultValue: '', description: "Введите новое регулярное выражение для замены ${regexToModify}")]
            )

            def newRegex = newRegexInput["newRegex"]

            // Шаг 5: Замена старого регулярного выражения на новое
            updatedFilter.spec.configPatches.each { patch ->
                def rules = patch.patch?.value?.typed_config?.rules
                if (rules?.policies) {
                    rules.policies.each { policyName, policyValue ->
                        def permissions = policyValue.permissions
                        def prefixExists = permissions?.any { permission ->
                            permission.and_rules?.rules?.any { rule ->
                                rule.url_path?.path?.prefix == prefix
                            }
                        }

                        if (prefixExists) {
                            policyValue.principals.each { principal ->
                                if (principal.header?.safe_regex_match?.regex == regexToModify) {
                                    log.infoCustom "Замена регулярного выражения ${regexToModify} на ${newRegex} для префикса ${prefix}"
                                    principal.header.safe_regex_match.regex = newRegex
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
