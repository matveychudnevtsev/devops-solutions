def oc_tool = tool(name: 'oc-3.11', type: 'oc')
def helm_tool = tool(name: 'helm-3.5', type: 'helm') // Используем Helm 3.5, обновите, если необходимо
def helm_tool = tool name: 'helm-v3.6.3', type: 'com.cloudbees.jenkins.plugins.customtools.CustomTool'

// Получение списка релизов Helm
def helmReleases = sh(script: "${helm_tool}/helm list -a --kubeconfig=${KUBECONFIG} -o json", returnStdout: true).trim()

// Получение списка элементов в проекте
def ListEl = null
try {
    ListEl = sh(script: "set +x; ${oc_tool}/oc get --config=${KUBECONFIG} all,ingress,configmaps,globalratelimits,serviceentries,gateways,destinationrules,virtualservices,envoyfilters,sidecars -o name | grep -v -E 'replicaset.apps/|configmap/istio-ca-root-cert|configmap/kube-root.ca.crt|configmap/openshift-service-ca.crt'", returnStdout: true).trim()
} catch (Exception e) {
    println("Нечего удалять")
}

// Если есть ресурсы для удаления или релизы Helm
if (ListEl || helmReleases) {
    println(ListEl)
    def ListElbr = ListEl.replaceAll("\n", "<br>")
    
    // Добавляем сообщение для релизов Helm
    def helmReleasesFormatted = helmReleases.replaceAll("\n", "<br>")
    
    // Добавляем чекбокс для подтверждения удаления элементов проекта
    def BoolDelete = input message: "Запустить удаление указанных элементов?",
        parameters: [booleanParam(defaultValue: true, 
            description: "<strong>Список элементов</strong><br>${ListElbr}", 
            name: "BoolDelete")]
    
    // Добавляем чекбокс для подтверждения удаления релизов Helm
    def BoolHelmDelete = input message: "Запустить удаление релизов Helm?",
        parameters: [booleanParam(defaultValue: true, 
            description: "<strong>Список релизов Helm</strong><br>${helmReleasesFormatted}", 
            name: "BoolHelmDelete")]
    
    // Удаление ресурсов OpenShift
    if (BoolDelete) {
        def check_pods = sh(script: "${oc_tool}/oc get --config=${KUBECONFIG} deployments -o name", returnStdout: true).trim()
        if (check_pods) {
            sh "set +x; ${oc_tool}/oc scale --config=${KUBECONFIG} --replicas=0 \$(${oc_tool}/oc get --config=${KUBECONFIG} deployments -o name)"
        }
        try {
            sh "set +x; ${oc_tool}/oc delete --config=${KUBECONFIG} \$(${oc_tool}/oc get --config=${KUBECONFIG} all,ingress,configmaps,serviceentries,gateways,destinationrules,virtualservices,envoyfilters,sidecars -o name | grep -v -E 'replicaset.apps/|configmap/istio-ca-root-cert|configmap/kube-root.ca.crt|configmap/openshift-service-ca.crt')"
        } catch (Exception e) {
            println("Ошибка при удалении элементов: " + e.getMessage())
        }
    }
    
    // Удаление релизов Helm
    if (BoolHelmDelete) {
        def helmReleasesList = readJSON text: helmReleases
        helmReleasesList.each { release ->
            def releaseName = release.name
            try {
                sh "${helm_tool}/helm uninstall ${releaseName} --kubeconfig=${KUBECONFIG}"
            } catch (Exception e) {
                println("Ошибка при удалении релиза Helm: ${releaseName}, сообщение: " + e.getMessage())
            }
        }
    }
    
    // Удаление секретов Reflex
    def deleteSecrets = input message: "Удалить секреты Reflex?",
        parameters: [booleanParam(defaultValue: false, 
            description: "Секреты для удаления: dynatrace-data-ingest-endpoint, dynatrace-dynakube-config", 
            name: "DeleteReflexSecrets")]
    
    if (deleteSecrets) {
        try {
            sh "set +x; ${oc_tool}/oc delete secret dynatrace-data-ingest-endpoint dynatrace-dynakube-config --config=${KUBECONFIG}"
        } catch (Exception e) {
            println("Ошибка при удалении секретов: " + e.getMessage())
        }
    }
} else {
    println("Проект чистый")
}


----------


def oc_tool = tool(name: 'oc-3.11', type: 'oc')
def helm_tool = tool(name: 'helm-v3.6.3', type: 'com.cloudbees.jenkins.plugins.customtools.CustomTool') // Custom tool для Helm

// Получение списка релизов Helm
def helmReleases = sh(script: "${helm_tool}/helm list -a --kubeconfig=${KUBECONFIG} -o json", returnStdout: true).trim()

// Получение списка элементов в проекте
def ListEl = null
try {
    ListEl = sh(script: "set +x; ${oc_tool}/oc get --config=${KUBECONFIG} all,ingress,configmaps,globalratelimits,serviceentries,gateways,destinationrules,virtualservices,envoyfilters,sidecars -o name | grep -v -E 'replicaset.apps/|configmap/istio-ca-root-cert|configmap/kube-root.ca.crt|configmap/openshift-service-ca.crt'", returnStdout: true).trim()
} catch (Exception e) {
    println("Нечего удалять")
}

// Если есть ресурсы для удаления или релизы Helm
if (ListEl || helmReleases) {
    println(ListEl)
    def ListElbr = ListEl.replaceAll("\n", "<br>")
    
    // Форматируем список релизов Helm
    def helmReleasesFormatted = helmReleases.replaceAll("\n", "<br>")
    
    // Объединяем чекбоксы в один input
    def userInput = input message: "Запустить удаление указанных элементов?",
        parameters: [
            booleanParam(defaultValue: true, 
                description: "<strong>Список элементов</strong><br>${ListElbr}", 
                name: "BoolDelete"),
            booleanParam(defaultValue: true, 
                description: "<strong>Список релизов Helm</strong><br>${helmReleasesFormatted}", 
                name: "BoolHelmDelete")
        ]
    
    def BoolDelete = userInput['BoolDelete']
    def BoolHelmDelete = userInput['BoolHelmDelete']
    
    // Удаление ресурсов OpenShift
    if (BoolDelete) {
        def check_pods = sh(script: "${oc_tool}/oc get --config=${KUBECONFIG} deployments -o name", returnStdout: true).trim()
        if (check_pods) {
            sh "set +x; ${oc_tool}/oc scale --config=${KUBECONFIG} --replicas=0 \$(${oc_tool}/oc get --config=${KUBECONFIG} deployments -o name)"
        }
        try {
            sh "set +x; ${oc_tool}/oc delete --config=${KUBECONFIG} \$(${oc_tool}/oc get --config=${KUBECONFIG} all,ingress,configmaps,serviceentries,gateways,destinationrules,virtualservices,envoyfilters,sidecars -o name | grep -v -E 'replicaset.apps/|configmap/istio-ca-root-cert|configmap/kube-root.ca.crt|configmap/openshift-service-ca.crt')"
        } catch (Exception e) {
            println("Ошибка при удалении элементов: " + e.getMessage())
        }
    }
    
    // Удаление релизов Helm
    if (BoolHelmDelete) {
        def helmReleasesList = readJSON text: helmReleases
        helmReleasesList.each { release ->
            def releaseName = release.name
            try {
                sh "${helm_tool}/helm uninstall ${releaseName} --kubeconfig=${KUBECONFIG}"
            } catch (Exception e) {
                println("Ошибка при удалении релиза Helm: ${releaseName}, сообщение: " + e.getMessage())
            }
        }
    }
    
    // Удаление секретов Reflex
    def deleteSecrets = input message: "Удалить секреты Reflex?",
        parameters: [booleanParam(defaultValue: false, 
            description: "Секреты для удаления: dynatrace-data-ingest-endpoint, dynatrace-dynakube-config", 
            name: "DeleteReflexSecrets")]
    
    if (deleteSecrets) {
        try {
            sh "set +x; ${oc_tool}/oc delete secret dynatrace-data-ingest-endpoint dynatrace-dynakube-config --config=${KUBECONFIG}"
        } catch (Exception e) {
            println("Ошибка при удалении секретов: " + e.getMessage())
        }
    }
} else {
    println("Проект чистый")
}



----------


def getInfoBlockAndSubsystemAndClusters(def bitbucket, def repositoryNameCommonStand, def listStand) {
    // Создаем карту для хранения кластеров по стендам
    Map standMap = new LinkedHashMap()

    for (String stand : listStand) {
        // Создаем карту для хранения подсистем и их кластеров для каждого стенда
        def configDirMap = new LinkedHashMap()

        // Переходим к конкретному репозиторию и директории для этого стенда
        script.dir("${repositoryNameCommonStand}_${stand}") {
            bitbucket.downloadRepository("${repositoryNameCommonStand}_${stand}")
            
            // Получаем список всех директорий, рекурсивно, чтобы обработать вложенные
            def str = script.sh(script: "find . -type d", returnStdout: true)
            def arrStr = str.split("\n")

            // Проходим по каждой найденной директории
            arrStr.each { configDir -> 
                // Убираем './' в начале пути к директории
                def cleanConfigDir = configDir.replaceFirst("^\\./", "")

                // Определяем путь к файлу subsystems.json
                def subsystemFilePath = "${cleanConfigDir}/subsystems.json"
                
                // Проверяем, существует ли файл
                def fileExists = script.sh(script: "[ -f ${subsystemFilePath} ] && echo 'true' || echo 'false'", returnStdout: true).trim()

                if (fileExists == 'true') {
                    // Читаем содержимое файла subsystems.json
                    def fileContent = script.sh(script: "cat ${subsystemFilePath}", returnStdout: true)

                    // Получаем список подсистем из содержимого файла
                    def subsystemList = getListSubsystemNew(fileContent)

                    // Создаем карту для хранения кластеров для каждой подсистемы
                    def subsystemsMap = [:]

                    // Проходим по каждой подсистеме и получаем ее кластеры
                    subsystemList.each { subsystem ->
                        def clusters = getClustersFromSubsystem(fileContent, subsystem)
                        subsystemsMap["${subsystem}"] = clusters.collect { cluster -> "'${cluster}'" }
                    }

                    // Добавляем информацию о подсистемах и кластерах в карту для этой директории
                    configDirMap[cleanConfigDir] = subsystemsMap
                } else {
                    // Если файл не найден, продолжаем цикл (обрабатываем другие директории)
                    script.echo "File ${subsystemFilePath} not found, checking nested directories."
                }
            }
        }

        // Добавляем карту конфигурационных директорий в основную карту для этого стенда
        standMap[stand] = configDirMap
    }

    return standMap
}




----------




def oc_tool = tool(name: 'oc-3.11', type: 'oc')
def helm_tool = tool(name: 'helm-v3.6.3', type: 'com.cloudbees.jenkins.plugins.customtools.CustomTool') // Custom tool для Helm

// Функция для проверки наличия ресурса на кластере
def resourceExists(resourceType) {
    try {
        sh(script: "${oc_tool}/oc get --config=${KUBECONFIG} ${resourceType} --ignore-not-found", returnStdout: true).trim()
        return true
    } catch (Exception e) {
        return false
    }
}

// Получение списка релизов Helm в формате JSON
def helmReleases = sh(script: "${helm_tool}/helm list -a --kubeconfig=${KUBECONFIG} -o json", returnStdout: true).trim()

// Преобразование JSON-ответа в более читаемый формат с полями name и chart
def helmReleasesFormatted = ""
if (helmReleases) {
    def helmReleasesList = readJSON text: helmReleases
    helmReleasesList.each { release ->
        helmReleasesFormatted += "Релиз: ${release.name}, Чарт: ${release.chart}<br>"
    }
}

// Проверка наличия ресурса "globalratelimits"
def globalRatelimitsAvailable = resourceExists('globalratelimits')

// Формируем команду для получения списка ресурсов, исключая globalratelimits, если его нет
def resourceTypes = "all,ingress,configmaps,serviceentries,gateways,destinationrules,virtualservices,envoyfilters,sidecars"
if (globalRatelimitsAvailable) {
    resourceTypes += ",globalratelimits"
}

// Получение списка элементов в проекте
def ListEl = null
try {
    ListEl = sh(script: "set +x; ${oc_tool}/oc get --config=${KUBECONFIG} ${resourceTypes} -o name | grep -v -E 'replicaset.apps/|configmap/istio-ca-root-cert|configmap/kube-root.ca.crt|configmap/openshift-service-ca.crt'", returnStdout: true).trim()
} catch (Exception e) {
    println("Нечего удалять")
}

// Если есть ресурсы для удаления или релизы Helm
if (ListEl || helmReleasesFormatted) {
    println(ListEl)
    def ListElbr = ListEl ? ListEl.replaceAll("\n", "<br>") : ""

    // Объединяем чекбоксы в один input
    def userInput = input message: "Запустить удаление указанных элементов?",
        parameters: [
            booleanParam(defaultValue: true, 
                description: "<strong>Список элементов</strong><br>${ListElbr}", 
                name: "BoolDelete"),
            booleanParam(defaultValue: true, 
                description: "<strong>Список релизов Helm</strong><br>${helmReleasesFormatted}", 
                name: "BoolHelmDelete")
        ]
    
    def BoolDelete = userInput['BoolDelete']
    def BoolHelmDelete = userInput['BoolHelmDelete']
    
    // Удаление ресурсов OpenShift
    if (BoolDelete) {
        def check_pods = sh(script: "${oc_tool}/oc get --config=${KUBECONFIG} deployments -o name", returnStdout: true).trim()
        if (check_pods) {
            sh "set +x; ${oc_tool}/oc scale --config=${KUBECONFIG} --replicas=0 \$(${oc_tool}/oc get --config=${KUBECONFIG} deployments -o name)"
        }
        try {
            sh "set +x; ${oc_tool}/oc delete --config=${KUBECONFIG} \$(${oc_tool}/oc get --config=${KUBECONFIG} ${resourceTypes} -o name | grep -v -E 'replicaset.apps/|configmap/istio-ca-root-cert|configmap/kube-root.ca.crt|configmap/openshift-service-ca.crt')"
        } catch (Exception e) {
            println("Ошибка при удалении элементов: " + e.getMessage())
        }
    }
    
    // Удаление релизов Helm
    if (BoolHelmDelete) {
        def helmReleasesList = readJSON text: helmReleases
        helmReleasesList.each { release ->
            def releaseName = release.name
            try {
                sh "${helm_tool}/helm uninstall ${releaseName} --kubeconfig=${KUBECONFIG}"
            } catch (Exception e) {
                println("Ошибка при удалении релиза Helm: ${releaseName}, сообщение: " + e.getMessage())
            }
        }
    }
    
    // Удаление секретов Reflex
    def deleteSecrets = input message: "Удалить секреты Reflex?",
        parameters: [booleanParam(defaultValue: false, 
            description: "Секреты для удаления: dynatrace-data-ingest-endpoint, dynatrace-dynakube-config", 
            name: "DeleteReflexSecrets")]
    
    if (deleteSecrets) {
        try {
            sh "set +x; ${oc_tool}/oc delete secret dynatrace-data-ingest-endpoint dynatrace-dynakube-config --config=${KUBECONFIG}"
        } catch (Exception e) {
            println("Ошибка при удалении секретов: " + e.getMessage())
        }
    }
} else {
    println("Проект чистый")
}
