def modifyHeaders(selectedManifest, userInputPolicies, manifestsMap, envoyFilters) {
    selectedManifest.each { manifestName ->
        // Шаг 1: Пользователь выбирает префиксы
        def selectedPrefixes = userInputPolicies[manifestName].findAll { k, v -> v == true }.keySet()
        def updatedFilter = envoyFilters.items.find { it.metadata.name == manifestName }

        selectedPrefixes.each { prefix ->
            log.infoCustom "Обработка изменения headers для префикса ${prefix} в ${manifestName}"

            // Преобразуем префикс в безопасный для ключей формат
            def safePrefix = prefix.replaceAll(/[\/]/, "_")

            // Шаг 2: Поиск существующих регулярных выражений в выбранных префиксах
            def existingRegexes = [:]  // Храним regex в виде карты: ключ — уникальный ID, значение — regex
            updatedFilter.spec.configPatches.each { patch ->
                def rules = patch.patch?.value?.typed_config?.rules
                if (rules?.policies) {
                    rules.policies.each { policyName, policyValue ->
                        // Проверка на наличие соответствующего prefix
                        def permissions = policyValue.permissions
                        def prefixExists = permissions?.any { permission ->
                            permission.and_rules?.rules?.any { rule ->
                                rule.url_path?.path?.prefix == prefix
                            }
                        }

                        if (prefixExists) {
                            policyValue.principals.eachWithIndex { principal, index ->
                                if (principal.header?.safe_regex_match?.regex) {
                                    def regex = principal.header.safe_regex_match.regex
                                    existingRegexes["regex_${safePrefix}_${index}"] = regex
                                }
                            }
                        }
                    }
                }
            }

            // Шаг 3: Пользователь видит существующие регулярные выражения и может их изменить
            def regexInputs = []
            existingRegexes.each { key, regex ->
                regexInputs.add(
                    string(name: key, defaultValue: regex, description: "Изменить регулярное выражение: ${regex}")
                )
            }

            def modifiedRegexes = input(
                id: "userInputModifyRegexes_${manifestName}_${safePrefix}",
                message: "Измените регулярные выражения для префикса ${prefix}",
                parameters: regexInputs
            )

            // Шаг 4: Обновляем регулярные выражения на основе пользовательского ввода
            updatedFilter.spec.configPatches.each { patch ->
                def rules = patch.patch?.value?.typed_config?.rules
                if (rules?.policies) {
                    rules.policies.each { policyName, policyValue ->
                        def permissions = policyValue.permissions
                        def prefixExists = permissions?.any { permission ->
                            permission.and_rules?.rules?.any { rule ->
                                rule.url_path?.path?.prefix == prefix
                            }
                        }

                        if (prefixExists) {
                            policyValue.principals.eachWithIndex { principal, index ->
                                def key = "regex_${safePrefix}_${index}"
                                if (principal.header?.safe_regex_match?.regex && modifiedRegexes[key]) {
                                    log.infoCustom "Замена регулярного выражения ${principal.header.safe_regex_match.regex} на ${modifiedRegexes[key]}"
                                    principal.header.safe_regex_match.regex = modifiedRegexes[key]
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
